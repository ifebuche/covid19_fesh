<<<<<<< HEAD
=======
# The following comment should be removed at some point in the future.
# mypy: disallow-untyped-defs=False

from __future__ import absolute_import

>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
import datetime
import hashlib
import json
import logging
<<<<<<< HEAD
import optparse
import os.path
import sys
from typing import Any, Dict

from pip._vendor.packaging.version import parse as parse_version

from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import get_default_environment
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.network.session import PipSession
from pip._internal.utils.filesystem import adjacent_tmp_file, check_path_owner, replace
from pip._internal.utils.misc import ensure_dir
=======
import os.path
import sys

from pip._vendor import pkg_resources
from pip._vendor.packaging import version as packaging_version
from pip._vendor.six import ensure_binary

from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.models.search_scope import SearchScope
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.utils.filesystem import (
    adjacent_tmp_file,
    check_path_owner,
    replace,
)
from pip._internal.utils.misc import (
    ensure_dir,
    get_installed_version,
    redact_auth_from_url,
)
from pip._internal.utils.packaging import get_installer
from pip._internal.utils.typing import MYPY_CHECK_RUNNING

if MYPY_CHECK_RUNNING:
    import optparse
    from optparse import Values
    from typing import Any, Dict, Text, Union

    from pip._internal.network.session import PipSession

>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef

SELFCHECK_DATE_FMT = "%Y-%m-%dT%H:%M:%SZ"


logger = logging.getLogger(__name__)


<<<<<<< HEAD
def _get_statefile_name(key: str) -> str:
    key_bytes = key.encode()
=======
def make_link_collector(
    session,  # type: PipSession
    options,  # type: Values
    suppress_no_index=False,  # type: bool
):
    # type: (...) -> LinkCollector
    """
    :param session: The Session to use to make requests.
    :param suppress_no_index: Whether to ignore the --no-index option
        when constructing the SearchScope object.
    """
    index_urls = [options.index_url] + options.extra_index_urls
    if options.no_index and not suppress_no_index:
        logger.debug(
            'Ignoring indexes: %s',
            ','.join(redact_auth_from_url(url) for url in index_urls),
        )
        index_urls = []

    # Make sure find_links is a list before passing to create().
    find_links = options.find_links or []

    search_scope = SearchScope.create(
        find_links=find_links, index_urls=index_urls,
    )

    link_collector = LinkCollector(session=session, search_scope=search_scope)

    return link_collector


def _get_statefile_name(key):
    # type: (Union[str, Text]) -> str
    key_bytes = ensure_binary(key)
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
    name = hashlib.sha224(key_bytes).hexdigest()
    return name


<<<<<<< HEAD
class SelfCheckState:
    def __init__(self, cache_dir: str) -> None:
        self.state: Dict[str, Any] = {}
=======
class SelfCheckState(object):
    def __init__(self, cache_dir):
        # type: (str) -> None
        self.state = {}  # type: Dict[str, Any]
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
        self.statefile_path = None

        # Try to load the existing state
        if cache_dir:
            self.statefile_path = os.path.join(
                cache_dir, "selfcheck", _get_statefile_name(self.key)
            )
            try:
<<<<<<< HEAD
                with open(self.statefile_path, encoding="utf-8") as statefile:
                    self.state = json.load(statefile)
            except (OSError, ValueError, KeyError):
=======
                with open(self.statefile_path) as statefile:
                    self.state = json.load(statefile)
            except (IOError, ValueError, KeyError):
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
                # Explicitly suppressing exceptions, since we don't want to
                # error out if the cache file is invalid.
                pass

    @property
<<<<<<< HEAD
    def key(self) -> str:
        return sys.prefix

    def save(self, pypi_version: str, current_time: datetime.datetime) -> None:
=======
    def key(self):
        return sys.prefix

    def save(self, pypi_version, current_time):
        # type: (str, datetime.datetime) -> None
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
        # If we do not have a path to cache in, don't bother saving.
        if not self.statefile_path:
            return

        # Check to make sure that we own the directory
        if not check_path_owner(os.path.dirname(self.statefile_path)):
            return

        # Now that we've ensured the directory is owned by this user, we'll go
        # ahead and make sure that all our directories are created.
        ensure_dir(os.path.dirname(self.statefile_path))

        state = {
            # Include the key so it's easy to tell which pip wrote the
            # file.
            "key": self.key,
            "last_check": current_time.strftime(SELFCHECK_DATE_FMT),
            "pypi_version": pypi_version,
        }

        text = json.dumps(state, sort_keys=True, separators=(",", ":"))

        with adjacent_tmp_file(self.statefile_path) as f:
<<<<<<< HEAD
            f.write(text.encode())
=======
            f.write(ensure_binary(text))
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef

        try:
            # Since we have a prefix-specific state file, we can just
            # overwrite whatever is there, no need to check.
            replace(f.name, self.statefile_path)
        except OSError:
            # Best effort.
            pass


<<<<<<< HEAD
def was_installed_by_pip(pkg: str) -> bool:
=======
def was_installed_by_pip(pkg):
    # type: (str) -> bool
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
    """Checks whether pkg was installed by pip

    This is used not to display the upgrade message when pip is in fact
    installed by system package manager, such as dnf on Fedora.
    """
<<<<<<< HEAD
    dist = get_default_environment().get_distribution(pkg)
    return dist is not None and "pip" == dist.installer


def pip_self_version_check(session: PipSession, options: optparse.Values) -> None:
=======
    try:
        dist = pkg_resources.get_distribution(pkg)
        return "pip" == get_installer(dist)
    except pkg_resources.DistributionNotFound:
        return False


def pip_self_version_check(session, options):
    # type: (PipSession, optparse.Values) -> None
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
    """Check for an update for pip.

    Limit the frequency of checks to once per week. State is stored either in
    the active virtualenv or in the user's USER_CACHE_DIR keyed off the prefix
    of the pip script path.
    """
<<<<<<< HEAD
    installed_dist = get_default_environment().get_distribution("pip")
    if not installed_dist:
        return

    pip_version = installed_dist.version
=======
    installed_version = get_installed_version("pip")
    if not installed_version:
        return

    pip_version = packaging_version.parse(installed_version)
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
    pypi_version = None

    try:
        state = SelfCheckState(cache_dir=options.cache_dir)

        current_time = datetime.datetime.utcnow()
        # Determine if we need to refresh the state
        if "last_check" in state.state and "pypi_version" in state.state:
            last_check = datetime.datetime.strptime(
<<<<<<< HEAD
                state.state["last_check"], SELFCHECK_DATE_FMT
=======
                state.state["last_check"],
                SELFCHECK_DATE_FMT
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
            )
            if (current_time - last_check).total_seconds() < 7 * 24 * 60 * 60:
                pypi_version = state.state["pypi_version"]

        # Refresh the version if we need to or just see if we need to warn
        if pypi_version is None:
            # Lets use PackageFinder to see what the latest pip version is
<<<<<<< HEAD
            link_collector = LinkCollector.create(
=======
            link_collector = make_link_collector(
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
                session,
                options=options,
                suppress_no_index=True,
            )

            # Pass allow_yanked=False so we don't suggest upgrading to a
            # yanked version.
            selection_prefs = SelectionPreferences(
                allow_yanked=False,
                allow_all_prereleases=False,  # Explicitly set to False
            )

            finder = PackageFinder.create(
                link_collector=link_collector,
                selection_prefs=selection_prefs,
<<<<<<< HEAD
                use_deprecated_html5lib=(
                    "html5lib" in options.deprecated_features_enabled
                ),
=======
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
            )
            best_candidate = finder.find_best_candidate("pip").best_candidate
            if best_candidate is None:
                return
            pypi_version = str(best_candidate.version)

            # save that we've performed a check
            state.save(pypi_version, current_time)

<<<<<<< HEAD
        remote_version = parse_version(pypi_version)

        local_version_is_older = (
            pip_version < remote_version
            and pip_version.base_version != remote_version.base_version
            and was_installed_by_pip("pip")
=======
        remote_version = packaging_version.parse(pypi_version)

        local_version_is_older = (
            pip_version < remote_version and
            pip_version.base_version != remote_version.base_version and
            was_installed_by_pip('pip')
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
        )

        # Determine if our pypi_version is older
        if not local_version_is_older:
            return

        # We cannot tell how the current pip is available in the current
        # command context, so be pragmatic here and suggest the command
        # that's always available. This does not accommodate spaces in
<<<<<<< HEAD
        # `sys.executable` on purpose as it is not possible to do it
        # correctly without knowing the user's shell. Thus,
        # it won't be done until possible through the standard library.
        # Do not be tempted to use the undocumented subprocess.list2cmdline.
        # It is considered an internal implementation detail for a reason.
        pip_cmd = f"{sys.executable} -m pip"
=======
        # `sys.executable`.
        pip_cmd = "{} -m pip".format(sys.executable)
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
        logger.warning(
            "You are using pip version %s; however, version %s is "
            "available.\nYou should consider upgrading via the "
            "'%s install --upgrade pip' command.",
<<<<<<< HEAD
            pip_version,
            pypi_version,
            pip_cmd,
=======
            pip_version, pypi_version, pip_cmd
>>>>>>> 27dd9875f98c51b82553091a9dbcf027191524ef
        )
    except Exception:
        logger.debug(
            "There was an error checking the latest version of pip",
            exc_info=True,
        )
